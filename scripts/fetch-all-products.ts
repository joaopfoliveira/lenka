/**
 * Fetch ALL products from ALL sources
 * Combines Supermarket + Amazon + Future sources
 */

import { writeFileSync } from 'fs';
import path from 'path';
import { fetchers } from '../lib/fetchers';
import { Product, ProductCollection, filterProducts } from '../lib/productTypes';

async function fetchAllProducts() {
  console.log('ðŸš€ Fetching products from ALL sources...\n');
  console.log(`ðŸ“¦ Available sources: ${fetchers.map(f => f.name).join(', ')}\n`);

  const allProducts: Product[] = [];
  const sources: ProductCollection['sources'] = {};

  // Fetch from each source
  for (const fetcher of fetchers) {
    console.log(`\n${'='.repeat(60)}`);
    console.log(`ðŸ“¡ Source: ${fetcher.name}`);
    console.log(`${'='.repeat(60)}\n`);

    try {
      const products = await fetcher.fetch({
        maxProducts: fetcher.source === 'supermarket' ? 70 : 20,
        minPrice: 0.5,
        maxPrice: 300,
      });

      allProducts.push(...products);
      
      sources[fetcher.source] = {
        count: products.length,
        lastUpdated: new Date().toISOString(),
      };

      console.log(`âœ… ${fetcher.source}: ${products.length} products\n`);
    } catch (error: any) {
      console.error(`âŒ ${fetcher.source} failed:`, error.message);
      sources[fetcher.source] = {
        count: 0,
        lastUpdated: new Date().toISOString(),
      };
    }
  }

  // Calculate metadata
  const prices = allProducts.map(p => p.price);
  const categoryCounts: Record<string, number> = {};
  
  allProducts.forEach(p => {
    categoryCounts[p.category] = (categoryCounts[p.category] || 0) + 1;
  });

  const collection: ProductCollection = {
    products: allProducts,
    sources,
    metadata: {
      totalProducts: allProducts.length,
      averagePrice: prices.reduce((a, b) => a + b, 0) / prices.length,
      priceRange: {
        min: Math.min(...prices),
        max: Math.max(...prices),
      },
      categories: categoryCounts,
    },
  };

  console.log(`\n${'='.repeat(60)}`);
  console.log('ðŸ“Š SUMMARY');
  console.log(`${'='.repeat(60)}\n`);
  console.log(`âœ… Total products: ${collection.metadata.totalProducts}`);
  console.log(`ðŸ’° Average price: â‚¬${collection.metadata.averagePrice.toFixed(2)}`);
  console.log(`ðŸ“ˆ Price range: â‚¬${collection.metadata.priceRange.min.toFixed(2)} - â‚¬${collection.metadata.priceRange.max.toFixed(2)}`);
  console.log(`\nðŸ“¦ Products by source:`);
  Object.entries(collection.sources).forEach(([source, info]) => {
    console.log(`   ${source}: ${info.count} products`);
  });
  console.log(`\nðŸ“‚ Products by category:`);
  Object.entries(collection.metadata.categories)
    .sort((a, b) => b[1] - a[1])
    .forEach(([category, count]) => {
      console.log(`   ${category}: ${count} products`);
    });

  // Generate products.ts file
  const outputPath = path.join(__dirname, '..', 'data', 'products.ts');
  
  const fileContent = `// Auto-generated by fetch-all-products.ts
// Last updated: ${new Date().toISOString()}
// Sources: ${Object.keys(collection.sources).join(', ')}

import { Product, ProductCollection } from '../lib/productTypes';

const productCollection: ProductCollection = ${JSON.stringify(collection, null, 2)};

// For backward compatibility
export const products: Product[] = productCollection.products;

export function getRandomProducts(count: number): Product[] {
  const shuffled = [...products].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

export function getProductsBySource(source: string): Product[] {
  return products.filter(p => p.source === source);
}

export function getProductsByCategory(category: string): Product[] {
  return products.filter(p => p.category === category);
}

export function getProductsByPriceRange(min: number, max: number): Product[] {
  return products.filter(p => p.price >= min && p.price <= max);
}

export { productCollection };
export default products;

// Type exports for convenience
export type { Product, ProductCollection } from '../lib/productTypes';
`;

  writeFileSync(outputPath, fileContent, 'utf-8');
  console.log(`\nðŸ’¾ Saved to: ${outputPath}`);

  // Show sample products from each source
  console.log(`\nðŸ“¦ Sample products:\n`);
  
  for (const source of Object.keys(collection.sources)) {
    const sourceProducts = allProducts.filter(p => p.source === source);
    if (sourceProducts.length > 0) {
      console.log(`   ${source.toUpperCase()}:`);
      sourceProducts.slice(0, 3).forEach(p => {
        console.log(`     - ${p.name} (${p.brand || 'N/A'}) - â‚¬${p.price} @ ${p.store}`);
      });
      console.log();
    }
  }

  console.log('ðŸŽ‰ All products fetched successfully!');
}

fetchAllProducts().catch(console.error);

